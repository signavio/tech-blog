---
title: "Hands-on Hy"
description: "A rookie's practical introduction to the Hy programming language"
author: Timotheus Kampik
tags: Hy, Hylang, Python, Lisp
layout: article
image:
  feature: /2017/squid.jpg
  alt: Squid
---

[Hy](http://docs.hylang.org/en/stable/#) is a Lisp dialect that runs on top of - and tightly integrates with - Python.
Considering the rise of Python to the top of many programming language rankings (for example [the one published by IEEE](https://spectrum.ieee.org/computing/software/the-2017-top-programming-languages)) and the rediscovery of functional programming patterns by the software development mainstream, I was curious if Hy succeeds in bringing the functional paradigm to one of the most popular programming ecosystems.

## Getting started with Hy
The [tutorial](http://docs.hylang.org/en/stable/tutorial.html) in the official Hy documentation excels at providing and overview of the language's most important concepts and helped me get my first code running in a matter of minutes.
Still, the docs don't recommend and don't even mention any tooling that's available around Hy and I couldn't find such on my own.
That's why I decided to use PyCharm as my IDE.

[PyCharm](https://www.jetbrains.com/pycharm/) allows me to leverage Hy's Python integration to conveniently run, debug  and (potentially) test Hy code.
Because syntactically, Hy &asymp; Lisp &asymp; Clojure, I installed a [Clojure](https://plugins.jetbrains.com/plugin/8636-clojure-kit) plugin for PyCharm and added ``*.hy`` to the list of file types the system highlights as Clojure code. I had to disable *inspections* for Clojure in the PyCharm settings to not get prompted for any errors.
When I had trouble with Hy's syntax while programming, I used ``Lisp`` or ``Clojure`` instead of ``Hy`` in my search engine queries.

## Implementing a basic neural network with Hy
Now, as we have the basics covered, let's write some code.
As an example, I picked a basic neural network (gradient descent) as presented by Siraj Raval in [this YouTube video](https://www.youtube.com/watch?v=h3l4qz76JhQ) and implemented it in Hy instead of Python.

In Hy, we can import any Python library - in our example *numpy*.
We can also require a set of Hy extensions, so called [contributor modules](http://docs.hylang.org/en/stable/contrib/index.html):

```clojure
(import numpy)
(require [hy.contrib.loop [loop]])
```

After defining the dependencies, we're ready to start with the actual neural network implementation.
First, we define a [signoid function](https://en.wikipedia.org/wiki/Sigmoid_function) as our activation function.
Like in Lisp, in Hy operators are proper variadic functions and of course we need to use tons of parentheses:

```clojure
(defn nonlin [x &optional (derive False)] (
        if derive
        (return (* x (- 1 x)))
        (return (/ 1 (+ 1 (.exp numpy (- x)))))))
```

And here's the code that does the actual training.
To implement the training loop, we need the extension we required above.

```clojure
;; training
(defn train [synapses input-data index]
  (loop [[i index] [acc 1]]
    (global layer-2)
      (if (zero? i)
        [(return layer-2)]
        (recur (dec i)[  ;; do this `index` times
          (setv layer-0 input-data)
          (setv layer-1 (nonlin (.dot numpy layer-0 (get synapses 0))))
          (setv layer-2 (nonlin (.dot numpy layer-1 (get synapses 1))))
          (setv layer-2-error (- output-data layer-2))

          (if (= (% i 10000) 0)
              (print (+ "Error " (str (.mean numpy(.abs numpy layer-2-error))))))

          (setv layer-2-delta (* layer-2-error (nonlin layer-2 True)))
          (setv layer-1-error (.dot layer-2-delta (. (get synapses 1) T)))
          (setv layer-1-delta (* layer-1-error (nonlin layer-1 True)))
          ;; update weights
          (assoc synapses 0 (+ (get synapses 0) (.T.dot layer-0 layer-1-delta)))
          (assoc synapses 1 (+ (get synapses 1) (.T.dot layer-1 layer-2-delta)))]))))
```

Now, we can define our input data:

```clojure
(setv input-data
  (.array numpy ;; note: 3rd column contains bias term
    [[0 0 1]
     [0 1 1]
     [1 0 1]
     [1 1 1]]))

(setv output-data
  (.array numpy
    [[0]
     [1]
     [1]
     [0]]))

(.random.seed numpy 1)

(setv synapses {
                 0 (- (* 2 (.random.random numpy [3 4])) 1)
                 1 (- (* 2 (.random.random numpy [4 1])) 1)})
```

Finally, we run the training function with the input parameters we specified above:

```clojure
(print (+ "Output after training \n\r" (str (train synapses input-data 60000))))
```

You can also find the code on [GitHub](https://github.com/TimKam/hylang_gradient_descent).

For advanced, production-like use cases, it is possible to use further tools and services that support or were specifically created for Python.
For example, to enable continuous integration we could run unit tests with  [pytest](https://docs.pytest.org/en/latest/) and set up a continuous integration workflow with [Travis](https://travis-ci.org/) or [Circle CI](https://circleci.com/).

## Assessment: what's Hy good for?
Hy is a creative attempt to introduce a highly praised, but sparsely adopted functional programming language to the Python community.
Hy's Lisp-y syntax and its tight Python integration compensates to some degree for the lack of tooling.
This means that in most use cases, you can't use Hy on it's own, but need to use Python to manage aspects like testing and dependency management, and tooling for Lisp or other Lisp-based languages for syntax highlighting.
However, static code analysis isn't properly possible and will eventually require Hy-specific tooling.

Hy is syntactically more attractive for buffs who already know expert languages like Clojure.
The many parentheses might put off folks who are new to functional programming or know it primarily from modern JavaScript.
Some compromises were made to also support Pythonic syntax, most  notably *dot notation*:

```clojure
  (numpy.mean [1 5]) ;; returns 3
```

Still, I personally would like Hy to draw more inspiration from Pythonâ€™s syntax and support (significant) indentation instead of parentheses.

All in all, I think Hy brings a refreshingly new (or rather, *different*) approach to writing code to the Python ecosystem.
If experienced and visible Pythonistas continue to take up Hy, improve its tooling and available learning materials, and optimize its usability, they will encourage its adoption by the broader Python community and consequently boost the prevalence of functional programming knowledge in general.

<a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-family:-apple-system, BlinkMacSystemFont, &quot;San Francisco&quot;, &quot;Helvetica Neue&quot;, Helvetica, Ubuntu, Roboto, Noto, &quot;Segoe UI&quot;, Arial, sans-serif;font-size:12px;font-weight:bold;line-height:1.2;display:inline-block;border-radius:3px;" href="https://unsplash.com/@missd?utm_medium=referral&amp;utm_campaign=photographer-credit&amp;utm_content=creditBadge" target="_blank" rel="noopener noreferrer" title="Download free do whatever you want high-resolution photos from Antonella Lombardi"><span style="display:inline-block;padding:2px 3px;"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white;" viewBox="0 0 32 32"><title></title><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px;">Antonella Lombardi</span></a>
