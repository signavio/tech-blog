---
title: "Type your API today!"
description: "Our approach on how to gain more certainty about what to expect from both ends of an API"
tags: javascript, typescript, graphql, nodejs, swagger, rest, type, api, apollo, openapi, json, gradle, circleci
author: Pascalis Maschke
layout: article
image:
  feature: ../2019/swagster-title.jpg
  alt: Show me what you got â€“ API wise
---

As in many companies, our team combines both frontend and backend developers, more or less keen on residing in their respective engineering domain. We have a Java Backend exposing a REST-API that is consumed by an [Apollo GraphQL](https://www.apollographql.com/platform) server. These two services need to agree on an API. To avoid too much conversational incentive, in usually short meetings we define the API's endpoints.

Often enough, we face problems when the agreement made is not entirely followed through or interpreted differently by one of the involved parties. Thus being motivation to come up with a way to achieve _certainty_ about what is to be expected on both ends of the deal.

### I am a developer in Signavio's [Process Intelligence](https://www.signavio.com/products/process-intelligence/) product and I want to present you an idea how to attain said certainty. Basically, how to type an API end-to-end.

There are several things constantly enhancing my desire to work as a developer. Few beat my affection for slack bots and seemingly random acronyms. Unsurprisingly, the project's name was created long before most of the confluence page mapping out its future approach.

### SWAGSTER: Swagger Safe Typing Evaluation Repository.

![corresponding slack emoji](../2019/swagster-rick.jpg "Swagster Rick")

For everyone not familiar with [Swagger.io](https://swagger.io/), it is essentially a library that allows you to annotate your API related Java code to later on generate fancy overviews amongst other probably more relevant features (e.g. converts well to Postman).

With the generous help of a gradle plug-in simply called _swagger-gradle-plugin_ and a corresponding gradle task, we are able to generate an OpenAPI JSON that is easily understood by _Swagster_.

```java
resolve {
    outputFileName = 'open_api_schema'
    outputFormat = 'JSON'
    prettyPrint = 'TRUE'
// ...
}
```

In our NodeJS clad GraphQL server "_fluffy_" (named after a three-headed dog better known within the Harry Potter universe), we needed to get rid of the uncertainty JavaScript tends to provide in regards of typing, replacing it with another popular superset, namely TypeScript.

Some very low-key git magic transmits the JSON over to the _Swagster_ repo. This triggers a CircleCI job we mainly abuse as its "API", activating the pipeline.

### Now, the fun part begins.

_openapi-diff_ is an npm package designed to differentiate between two given files. Don't be fooled by their documentation, you can run it just as much from your node environment as from the command line.
We make use of that letting it identify for us, whether changes were made to the API.

If this turns out positive, we utilize the _ts-morph_ npm package to convert the transmitted OpenAPI JSON file to TypeScript through code generation.
As far as I have sailed the vast ocean of JavaScript, there is no easy way to do this other than iterating over the file extracting various kinds of information with a multitude of `if`-statements.
We write the functions into a `RESTDataSource` class provided by Apollo. For further information please see https://www.apollographql.com/docs/apollo-server/features/data-sources/.

### Example

Take this as part of the API specification in your OpenAPI file:

```json
"paths" : {
    "/houseelf/{houselfid}" : {
      "get" : {
        "operationId" : "getHouseElf",
        "parameters" : [ {
          "name" : "houselfid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
      "responses" : {
          "default" : {
            "description" : "default response",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/HouseElf"
                }
              }
            }
          }
        }
      }
    }
}
```

This is how it then looks like within our `RestDataSource` class:

```javascript
/*
 *  GET '/houseelf/{houseelfid}'
 */
getHouseElf(houselfid: string): Promise<Components.Schemas.HouseElf> {
    return this.get(`/houseelf/${houseelfid}`)
}
```

At the moment, we have our types produced by the npm package _dtsgen_ as in here:

```
yarn dtsgen --out src/types.d.ts src/open_api_schema.json
```

Meanwhile a Slack message is generated enumerating the endpoints that underwent alteration, which is then send to our monitoring channel. I normally add some Rick and Morty emojis here for good measure.

Eventually, the newly generated TypeScript code is published to both the _Swagster_ repository on git and npm.

![custom graphic](../2019/swagster-graphic.png "Swagster Magic")

### Outcome

Your API changes highly increase in visibility being reported to Slack.
Also reminding you to manually update the GraphQL server's _Swagster_ npm package to apply its output to the GraphQL resolvers.

There it comes in handy to experience type warnings through TypeScript in case you missed a change to the API.

_Swagster_ immensely reduces boiler plate code in the GraphQL server and also feels inherently safe with code generation being the means of implementation.

Thereby successfully concluding the type safety certainty effort from backend to GraphQL server to frontend.
