---
title: "Hands-on Hy"
description: "An introduction to the Hy programming language"
author: Timotheus Kampik
tags: Hy, Hylang, Python, Lisp
layout: article
image:
  feature: /2017/squid.jpg
  alt: Squid
---

<a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-family:-apple-system, BlinkMacSystemFont, &quot;San Francisco&quot;, &quot;Helvetica Neue&quot;, Helvetica, Ubuntu, Roboto, Noto, &quot;Segoe UI&quot;, Arial, sans-serif;font-size:12px;font-weight:bold;line-height:1.2;display:inline-block;border-radius:3px;" href="https://unsplash.com/@missd?utm_medium=referral&amp;utm_campaign=photographer-credit&amp;utm_content=creditBadge" target="_blank" rel="noopener noreferrer" title="Download free do whatever you want high-resolution photos from Antonella Lombardi"><span style="display:inline-block;padding:2px 3px;"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white;" viewBox="0 0 32 32"><title></title><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px;">Antonella Lombardi</span></a>

[Hy](http://docs.hylang.org/en/stable/#) is a Lisp dialect that runs on top of (and tightly integrates with) Python.
Considering the AI-driven rise of Python to the top of many programming language rankings (for example [the one published by IEEE](https://spectrum.ieee.org/computing/software/the-2017-top-programming-languages)) and the rediscovery of functional programing patterns by the software development mainstream, I was curious if Hy succeeds in bringing functional programing to the most powerful ecosystem for data science.

## Getting started with Hy
The [tutorial](http://docs.hylang.org/en/stable/tutorial.html) in the official Hy documentation excels at providing and overview of the language's most important concepts and helped me get my first code running in a matter of minutes.
Still, the docs don't recommend and not even mention any tooling that's available around Hy and I couldn't find such on my own.
That's why I decided to use [PyCharm](https://www.jetbrains.com/pycharm/) as my IDE.
This allows me to leverage Hy's Python integration to conveniently run, debug  and (potentially) test Hy code.
Because syntactically, Hy &asymp; Lisp &asymp; Clojure, I installed a [Clojure](https://plugins.jetbrains.com/plugin/8636-clojure-kit) plugin for PyCharm and added ``*.hy`` to the list of file types the system highlights as Clojure code. I had to disable *inspections* for Clojure in the PyCharm settings, however, to not get prompted any errors.
If I had trouble with Hy's syntax while programing, I used ``Lisp`` or ``Clojure`` instead of ``Hy`` in my search engine queries.

## Implementing a basic neural network with Hy
Now, as we have the basics covered, let's write some code.
In our example, we pick a basic neural network as presented by Siraj Raval in [this YouTube video](https://www.youtube.com/watch?v=h3l4qz76JhQ) and implement it in Hy instead of Python.

Lisp purists might not be happy with the code style.
For example, I largely stick to pythonic naming conventions so my names are consistent in style with the names the modules I import predetermine.

```clojure
(import numpy)
(require [hy.contrib.loop [loop]])

(defn nonlin [x &optional (derive False)] (
        if derive
        (return (* x (- 1 x)))
        (return (/ 1 (+ 1 (.exp numpy (- x)))))))

(setv input-data
  (.array numpy ;; note: 3rd column contains bias term
    [[0 0 1]
     [0 1 1]
     [1 0 1]
     [1 1 1]]))

(setv output-data
  (.array numpy
    [[0]
     [1]
     [1]
     [0]]))

(.random.seed numpy 1)

(setv synapses {
                 0 (- (* 2 (.random.random numpy [3 4])) 1)
                 1 (- (* 2 (.random.random numpy [4 1])) 1)})


;; training
(defn train [synapses index]
  (loop [[i index] [acc 1]]
      (if (zero? i)
        [(return layer-2)]
        (recur (dec i)[  ;; do this `index` times
          (setv layer-0 input-data)
          (setv layer-1 (nonlin (.dot numpy layer-0 (get synapses 0))))
          (global layer-2)
          (setv layer-2 (nonlin (.dot numpy layer-1 (get synapses 1))))
          (setv layer-2-error (- output-data layer-2))

          (if (= (% i 10000) 0)
              (print (+ "Error " (str (.mean numpy(.abs numpy layer-2-error))))))

          (setv layer-2-delta (* layer-2-error (nonlin layer-2 True)))
          (setv layer-1-error (.dot layer-2-delta (. (get synapses 1) T)))
          (setv layer-1-delta (* layer-1-error (nonlin layer-1 True)))
          ;; update weights
          (assoc synapses 0 (+ (get synapses 0) (.T.dot layer_0 layer-1-delta)))
          (assoc synapses 1 (+ (get synapses 1) (.T.dot layer_1 layer-2-delta)))]))))


(print (+ "Output after training \n\r" (str (train synapses 60000))))
```

## Assessment: what's Hy good for?
Hy is a creative attempt to introduce a highly praised, but sparsely adopted functional programing language to the Python community.
Hy's Lisp syntax and its tight Python integration compensates for lack of tooling. This also means that in most use cases, you can't use Hy on it's own, but need to use Python to manage aspects like testing and dependency management and tooling for Lisp or other Lisp-based languages for syntax highlighting.
However, static code analysis isn't properly possible and will eventually require Hy-specific tooling.
Moreover, Hy is syntactically more attractive for buffs who already know expert languages like Clojure. The many parentheses could put off folks who are new to functional programming or know it primarily through following modern JavaScript best practices.
That's why I personally would like Hy to draw some inspiration from Python when it comes to syntax and to allow using (significant) indentation instead of parentheses.

All in all, I think Hy brings a refreshingly new (or rather: *different*) approach of writing code to the Python ecosystem.
If experienced and visible Pythonistas continue to take up Hy, improve its tooling and available learning material, and optimize its usability, they will encourage its by the broader Python community and consequently boost the prevalence of functional programing knowledge in general.
